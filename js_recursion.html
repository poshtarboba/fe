<!DOCTYPE html>
<html>
<head>
	<title>Frontend. Рекурсія, глибоке копіювання об'єктів<!--, методи сортування--></title>
	<meta charset="utf-8">
	<meta name="keywords" content="">
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="format-detection" content="telephone=no">
	<link type="text/css" rel="stylesheet" href="style.css">
</head>
<body>
<div id="mainwrapper">
	<div class="resize">

		<h1>Рекурсія, глибоке копіювання об'єктів<!--, TODO: методи сортування--></h1>

		<p><a href="js_recursion.html" target="_blank">Лекція по рекурсії</a>.</p>
		<p><a href="http://lurkmore.to/%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D1%8F" target="_blank">Рекурсія на лурку</a>.</p>
		
		<section>
			<h2>Рекурсивний виклик функції</h2>
			<p><strong>Рекурсія</strong> - самоподібність. Тобто, це коли об'єкт містить свою самоподібну копію в собі.</p>
			<p>
				<a href="https://www.google.com/search?tbm=isch&q=рекурсія" target="_blank">Зображення на тему рекурсії</a><br>
				<a href="https://www.google.com/search?tbm=isch&q=nature%20fractals" target="_blank">Рекурсія в природі</a><br>
			</p>
			<p>У програмуванні рекурсивним викликом називається випадок, коли функція викликає сама себе в своєму тілі.</p>
			<p>З рекурсіями потрібно бути обережним - неакуратний виклик може створити "вічну" рекурсію, яка з'їсть всю доступну їй пам'ять і підвісить браузер.</p>
			<p>З одним варіантом рекурсії ми вже познайомилися на прикладі масивів. Додамо до нього рекурсивний виклик функції:</p>
			<code>
				var a = [];<br>
				a[0] = a;<br>
				console.log(a);<br><br>
				function recur(a){<br>
				&nbsp;&nbsp;console.log(a);<br>
				&nbsp;&nbsp;if (a < 1000000) { recur(a*2); }<br>
				}<br>
				recur(1);
			</code>
			<h3>Глибина рекурсії.</h3>
			<p>Рекурсія в теорії є нескінченною. Задля того, аби комп'ютери могли працювати з рекурсіями - кількість їх ітерацій обмежують. Кількість ітерацій називають глибиною рекурсії.</p>
			<p>Порахуйте глибину рекурсії у попередньому прикладі.</p>
			<h3>Пряма та непряма рекурсія.</h3>
			<p>При прямій рекурсія викликає саму себе, як у попередньому прикладі.</p>
			<p>При непрямій рекурсії функція A викликає функцію B, а та в свою чергу викликає функцію A:</p>
			<code>
				function fun1(){<br>
				&nbsp;&nbsp;...<br>
				&nbsp;&nbsp;fun2();<br>
				&nbsp;&nbsp;...<br>
				}<br>
				function fun2(){<br>
				&nbsp;&nbsp;...<br>
				&nbsp;&nbsp;fun1();<br>
				&nbsp;&nbsp;...<br>
				}<br>
				fun1();
			</code>
			<p>Ланцюжок може бути значно довшим, функції по черзі викликатимуть одна одну, і остання - викликатиме першу.</p>
			<h3>Завдання.</h3>
			<p>Виведіть в консоль рекурсією цифри від 10 до 0.</p>
			<p>Виведіть в консоль строки:</p>
			<code>
				1<br>
				21<br>
				321<br>
				4321<br>
				54321
			</code>
			<p>Внесіть невеликі зміни, щоб отримати:</p>
			<code>
				54321<br>
				4321<br>
				321<br>
				21<br>
				1
			</code>
		</section>

		<section>
			<h2>Практичне застосування рекурсії</h2>
			<h3>Пошук шляху.</h3>
			<p>Задача пошуку шляху є класичною для рекурсії. Застосовується у різноманітних напрямках розробки: іграх, розпізнаванні образів, пошуку ефективних моделей розвитку бізнеса, в навігаційних системах, роутінгу інформації і т.п.</p>
			<p>Розглянемо приклад пошуку шляху по лабіринту.</p>
			<figure>
				<img src="img/js_recursion_01.gif" alt="labyrinth">
				<figcaption>Лабіринт</figcaption>
			</figure>
			<p>З кожної точки лабіринту ми умовно можемо піти по чотирьох напрямках: вгору, вниз, вліво чи вправо, якщо нам не заважатимуть стіни. Нехай ми знаходимося в точці з координатами x та y. Напишемо функцію, яка обходить весь лабіринт:</p>
			<code>
				function goTo(x, y){<br>
				&nbsp;&nbsp;console.log('we are in position', x, y);<br>
				&nbsp;&nbsp;...<br>
				&nbsp;&nbsp;if (noWall(x - 1, y)) { goTo(x - 1, y); } &nbsp;&nbsp; // left<br>
				&nbsp;&nbsp;if (noWall(x + 1, y)) { goTo(x + 1, y); } &nbsp;&nbsp; // right<br>
				&nbsp;&nbsp;if (noWall(x, y - 1)) { goTo(x, y - 1); } &nbsp;&nbsp; // up<br>
				&nbsp;&nbsp;if (noWall(x, y + 1)) { goTo(x, y + 1); } &nbsp;&nbsp; // down<br>
				}<br>
				goTo(1, 1);
			</code>
			<p>Щоб наш скрипт не підвис - потрібно задати певну глибину, наприклад, максимум - 30 ходів. Якщо в лабіринті виявляться закільцьовані ходи, то без глибини рекурсія буде вічно блукати по колу.</p>
			<h3>Ігри.</h3>
			<p>В іграх рекурсії використовуються повсюдно, для пошуку шляхів, для імітації штучного інтелекту, для генерації світу, локацій і т.п.</p>
			<p>Рекурсією добре описуються такі ігри, як ханойські вежі, хрестики-нолики, шашки, шахмати та інші.</p>
			<h3>Фрактали.</h3>
			<p>Фрактал - нерегулярна, самоподібна структура. Є звичайні деревовидні фрактали, всілякі губки Менгера, трикутники Серпінського, є більш складні структури, що викоритовують комплексні числа з реальними та уявними множинами.</p>
			<figure>
				<img src="img/js_recursion_02.gif" alt="tree">
				<figcaption>Фрактальне дерево</figcaption>
			</figure>
			<figure>
				<img src="img/js_recursion_03.jpg" alt="trees">
				<figcaption>Фрактальні дерева в іграх</figcaption>
			</figure>
			<h3>Генерація віртуальних світів.</h3>
			<p>В жанрі ігор Rogue локації генеруються випадково за допомогою рекурсій.</p>
			<p>Різноманітні ігри також будують свої світи за допомогою рекурсій, глобально - всю територію, окремі локації, локально - розташування предметів, скарбів, побудова ландшафту, рослинного світу...</p>
			<p>Наприклад, весь світ гри Minecraft будується рекурсіями та фракталами. Завдяки цьому створюються гарні дивовижні структури, унікальні в межах всього світу розмірами 3,6 млрд. км<sup>2</sup> (площа всієї планети Земля - 0,51 млрд. км<sup>2</sup>). До того ж, в Minecraft можна створювати майже безкінечно велику кількість різноманітних світів.</p>
			<figure>
				<img src="img/js_recursion_04.jpg" alt="Minecraft">
				<figcaption>Ландшафт у Minecraft</figcaption>
			</figure>
			<h3>Генератор ландшафта</h3>
			<p>За допомогою рекурсій можна створювати правдоподібні ландшафти. Ви їх часто бачите у сучасних фільмах та іграх. Фільм знімають у павільйоні, а всі гори довкола - навіть не натурно зняті, а згенеровані рекурсією.</p>
			<p>Є невелика стара програмка <a href="http://nnm.me/blogs/cgface/terragen_0943_plugins_portable/" target="_blank">Terragen</a> версій 0.9.*, що дозволяє генерувати гірські пейзажі.</p>
			<figure>
				<img src="img/js_recursion_05.jpg" alt="Terragen">
				<figcaption>Інтерфейс программи Terragen 0.9</figcaption>
			</figure>
			<p>Сучасна версія програми значно потужніша:</p>
			<figure>
				<img src="img/js_recursion_06.jpg" alt="Terragen"><br><br>
				<img src="img/js_recursion_07.jpg" alt="Terragen">
				<figcaption>Пейзажі, згенеровані програмою Terragen 4</figcaption>
			</figure>
			<h3>Сортування.</h3>
			<p>За допомогою рекурсії можна сортувати масиви. Часто такі алгоритми виявляються оптимальнішими, швидше працюють, оскільки не перебирають багато разів одні і ті ж значення.</p>
			<p>
				Детальніше можна почитати за посиланнями:<br>
				<a href="http://www.tvd-home.ru/recursion" target="_blank">TVD: Рекурсия и рекурсивные алгоритмы</a>,<br>
				<a href="https://habrahabr.ru/post/275813/" target="_blank">Хабра: Рекурсия. Тренировочные задачи</a>.
			</p>
		</section>

		<section>
			<h2>Рекурсивне копіювання об'єктів</h2>
			<!-- TODO: видалити інфу про масиви, вони копіюються як і об'єкти через форін -->
			<p>Раніше ми розглянули копіювання об'єкта за допомогою оператора for-in.</p>
			<p>Цей спосіб буде працювати лише для простих типів даних. Та якщо в якості значення ключа буде масив чи інший об'єкт, ці структури не скопіюються, а скопіюються лише посилання на них. Таким чином, у оригінального та у скопійованого об'єкта будуть спільні масиви та об'єкти.</p>
			<p>Тому якщо ми зустрінемо тип даних ключа об'єкт чи масив - їх треба перебрати рекурсивно. Це називається <strong>глибоким копіюванням об'єкта</strong>.</p>
			<code>
				function copyObj(obj){<br>
				&nbsp;&nbsp;res = {};<br>
				&nbsp;&nbsp;for (var key in obj) {<br>
				&nbsp;&nbsp;&nbsp;&nbsp;if (typeof obj[key] === 'object') {<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (obj[key].length !== undefined) {<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res[key] = copyArr(obj[key]);<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res[key] = copyObj(obj[key]);<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
				&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res[key] = obj[key];<br>
				&nbsp;&nbsp;&nbsp;&nbsp;}<br>
				&nbsp;&nbsp;}<br>
				&nbsp;&nbsp;return res;<br>
				}
			</code>
			<p>Єдний ньюанс - при копіюванні масивів також потрібно враховувати тип даних кожного елемента масива.</p>
		</section>

		<!--<section>
			<h2>Методи сортування.</h2>
		</section>-->

		<section class="homework">
			<h2>Домашнє завдання</h2>
			<ol>
				<li>Виведіть рекурсією цифри від Z до A в консоль (використовуйте коди символів).</li>
			</ol>
			<p><strong>* Пошук скарбів</strong>.</p>
			<p>Дано лабіринт, його представлено у вигляді матриці розмірами 21 х 13:</p>
			<code>
				var lab = [<br>
				&nbsp;&nbsp;'111111111111111111111','100010000010001000001','111010111010111011101',<br>
				&nbsp;&nbsp;'100010101000000000101','101110101010111110111','100000100010100000101',<br>
				&nbsp;&nbsp;'101111111110101110101','101000100000100010001','111011101110111111111',<br>
				&nbsp;&nbsp;'100010000010000000001','101111101010111111101','100000001010001000001',<br>
				&nbsp;&nbsp;'111111111111111111111'<br>
				];
			</code>
			<p>Одиниці - це стіни, нулі - коридори.</p>
			<p>У лабіринті довільно розміщується точка початку гри та точка "скарб". Можна створити дві змінні з масивами з двох елементів, що відповідають координатам x та y:</p>
			<code>
			  var start = [5, 3],<br>
				&nbsp;&nbsp;&nbsp;&nbsp;gold = [7, 11];
			</code>
			<p>Створіть функцію, яка б вибирала довільно один з коридорів лабіринту і заміняла б його на точку початку.</p>
			<p>Застосуйте цю ж функцію для заміни нуля на літеру g.</p>
			<p>Відмалюйте лабіринт у браузері, використовуючи теги.</p>
			<p>Для відображення клітин коридорів чи стін зручно використовувати тег span, для горизонтальних рядків лабіринту - тег p, для всього лабіринту - тег div.</p>
			<code>
				div { width: 420px; border-left: 1px solid #999; border-top: 1px solid #999;}<br>
				p { margin: 0; font-size: 0; line-height: 0; }<br>
				span { display: inline-block; width: 19px; height: 19px; border-right: 1px solid #999; border-bottom: 1px solid #999;}<br>
				span.start { background: #080;}<br>
				span.wall { background: #999;}<br>
				span.gold { background: #fa0;}<br><br>
				// приклад маленького лабіринту:<br>
				div<br>
				&nbsp;p>.wall*5<br>
				&nbsp;p>.wall+.start+span*2+.wall<br>
				&nbsp;p>.wall+span+.wall+span+.wall<br>
				&nbsp;p>.wall+span+.wall+.gold+.wall<br>
				&nbsp;p>.wall*5
			</code>
			<p>Замість кольорів бекграунду можна задати текстуру кам'яної стіни, зображення шукача скарбів та скрині з золотом.</p>
			<p>Щоб створити лабіринт по заданій матриці - вам знадобляться деякі нові команди JavaScript.</p>
			<p>Створення тегів відбувається за допомогою метода document.createElement, елемент при цьому створюється в пам'яті.</p>
			<code>
				var span = document.createElement('span');<br>
				var p = document.createElement('p');<br>
				var div = document.createElement('div');
			</code>
			<p>Щоб задати елементу клас - використовується властивість className:</p>
			<code>
				span.className = 'active';<br>
				p.className = 'first';<br>
				div.className = 'labyrinth';
			</code>
			<p>Щоб добавити один елемент в інший - використовується метод appendChild:</p>
			<code>
				p.appendChild(span);<br>
				div.appendChild(p);<br>
				document.body.appendChild(div);
			</code>
			<p>Створіть функцію, яка б відмальовувала лабіринт у браузері.</p>
			<p>Керувати шукачем скарбів будемо вручну.</p>
			<p>Добавте на сторінку 4 кнопки з написами "up", "right", "down", "left" (або фоновими зображеннями стрілок).</p>
			<p>До кожної кнопки добавте onclick, перевіряйте, чи можна піти у заданому напрямку, якщо можна, то перемістіться у сусідню клітину.</p>
			<p>По досягненні точки зі скарбом виведіть на екран поздоровлення та запустіть гру знову з початку.</p>
			<p>Але який же лабіринт без мінотавра? добавте ще одну точку m.</p>
			<p>
				Після кожного ходу гравця мінотавр має зробити свій хід:<br>
				рекурсивно переберіть лабіринт (задайте глибину рекурсії 20), знайдіть гравця і по прокладеному маршруту рухайтеся на зустріч йому.<br>
				Якщо мінотавр зловить гравця - кінець гри. Почати гру заново.
			</p>
			<p>У випадку гри з мінотавром бажано добавити зациклень у лабіринт, тому що у багатьох випадках мінотавр буде відрізати гравця від скарбів, гру буде пройти неможливо.</p>
			<p>Наступний етап - автоматична генерація довільних лабіринтів і вже можна починати думати про вихід на комерційний ринок :).</p>
		</section>

		<!--
		
			Завдання: дано декілька блоків, розташованих в ряд. Потрібно знайти найбільшу висоту і задати її всім блокам як min-height.
			В класичному варіанті нам потрібно перебрати всі блоки, знайти серед них найвищий, перебрати їх повторно, задаючи кожному стиль.
			Виконайте це завдання.
			Спробуйте обійтися лише одним циклом перебору.
		
		-->
		
	</div>
</div>

<script src="jquery-3.1.1.min.js"></script>
<script src="fe.js"></script>

</body>
</html>