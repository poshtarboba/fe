<!DOCTYPE html>
<!DOCTYPE html>
<html>
<head>
	<title>Frontend. Асинхронний JS, Fetch</title>
	<meta charset="utf-8">
	<meta name="keywords" content="">
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="format-detection" content="telephone=no">
	<link type="text/css" rel="stylesheet" href="style.css">
</head>
<body>
<div id="mainwrapper">
	<div class="resize">

		<h1>Асинхронний JS, Fetch</h1>

		<section>
			<h2>Асинхронне завантаження і виконання зовнішніх скриптів</h2>
			<p>Розглянемо такий приклад:</p>
			<code>
				...<br>
				&lt;script src="js/counter.js"&gt;&lt;/script&gt;<br>
				&lt;script src="js/ad_box.js"&gt;&lt;/script&gt;<br>
				&lt;link type="text/css" rel="stylesheet" href="css/styles.css"&gt;<br>
				&lt;/head&gt;<br>
				&lt;body&gt;<br>
				...<br>
				&lt;script src=".../ga.js"&gt;&lt;/script&gt;<br>
				&lt;script src=".../ya.js"&gt;&lt;/script&gt;<br>
				&lt;script src=".../ra.js"&gt;&lt;/script&gt;<br>
				&lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;<br>
				&lt;script&gt;<br>
				&nbsp;&nbsp;$('body').css('background', 'yellow');<br>
				&nbsp;&nbsp;var h1 = document.querySelector('h1');<br>
				&nbsp;&nbsp;h1.innerHTML = h1.innerHTML + '!!!';<br>
				&lt;/script&gt;<br>
				&lt;/body&gt;&lt;/html&gt;
			</code>
			<p>
				В даному випадку всі події відбуваються синхронно:<br>
				- завантажується файл counter.js з лічильником відвідувачів;<br>
				- виконуються скрипти, що прописані в цьому файлі;<br>
				- завантажується файл ad_box.js, що відповідає за рекламу на сайті;<br>
				- виконуються скрипти, що прописані в цьому файлі;<br>
				- завантажуються стилі;<br>
				- лише зараз починає завантажуватися контент, користувач починає щось бачити на сторінці;<br>
				- завантажується скрипт аналітики гугла;<br>
				- виконується скрипт аналітики гугла, збирається статистика, відправляється на сервер;<br>
				- завантажується скрипт аналітики яндекса;<br>
				- виконується скрипт аналітики яндекса, збирається статистика, відправляється на сервер;<br>
				- завантажується скрипт аналітики рамблера;<br>
				- виконується скрипт аналітики рамблера, збирається статистика, відправляється на сервер;<br>
				- завантажується бібліотека jQuery;<br>
				- і лише тепер виконається наш скрипт, спочатку jQuery-залежна строка, і в самому кінці - дві строки на чистому JS.
			</p>
			<p>Часто такий алгоритм не тільки не зручний, але і шкідливий, недопустимий: лічильник і реклама можуть загрузитися, порахуватися, а користувач плюне і не дочекається завантаження контенту, через що відбудеться викривлення статистики та фінансові втрати.</p>
			<h3>Async.</h3>
			<p>Асинхронність дозволяє значно пришвидшити завантаження веб-сторінки, завантажуючи ресурси паралельно, не очікуючи один одного.</p>
			<p>Для асинхронного завантаження використовується властивість тега <strong>async</strong>, добавимо її в перші два скрипта і скрипти аналітики:</p>
			<code>
				...<br>
				&lt;script src="js/counter.js" async&gt;&lt;/script&gt;<br>
				&lt;script src="js/ad_box.js" async&gt;&lt;/script&gt;<br>
				...<br>
				&lt;script async src=".../ga.js"&gt;&lt;/script&gt;<br>
				&lt;script async src=".../ya.js"&gt;&lt;/script&gt;<br>
				&lt;script async src=".../ra.js"&gt;&lt;/script&gt;<br>
				...
			</code>
			<p>
				Тепер наш сайт завантажується в такому порядку:<br>
				- завантажуються стилі, а в фоні завантажуються файли counter.js та ad_box.js, скрипти виконаються коли завантажиться файл;<br>
				- починає завантажуватися контент, користувач починає щось бачити на сторінці;<br>
				- завантажується бібліотека jQuery, а в фоні завантажуються скрипти аналітики (три штуки одночасно) і по ходу діла в паралельних потоках обраховують свою статистику;<br>
				- тепер виконається наш скрипт, спочатку jQuery-залежна строка, і в самому кінці - на чистому JS.
			</p>
			<p>Проводимо оптимізацію швидкості далі. Останнім двом строчкам коду не потрібні бібліотеки, вони можуть бути виконані раніше:</p>
			<code>
				...<br>
				&lt;script&gt;<br>
				&nbsp;&nbsp;var h1 = document.querySelector('h1');<br>
				&nbsp;&nbsp;h1.innerHTML = h1.innerHTML + '!!!';<br>
				&lt;/script&gt;<br>
				&lt;script async src=".../ga.js"&gt;&lt;/script&gt;<br>
				...
			</code>
			<p>Або ще вище по коду, їх можна виконати одразу після завантаження відповідного тега:</p>
			<code>
				...<br>
				&lt;h1&gt;Заголовок сторінки&lt;/h1&gt;<br>
				&lt;script&gt;<br>
				&nbsp;&nbsp;var h1 = document.querySelector('h1');<br>
				&nbsp;&nbsp;h1.innerHTML = h1.innerHTML + '!!!';<br>
				&lt;/script&gt;<br>
				...
			</code>
			<p>В принципі, і jQuery можна завантажувати асинхронно, в такому випадку завантаження бібліотеки не буде тормозити виконання цих останніх двох строчок:</p>
			<code>
				...<br>
				&lt;script src="js/jquery.min.js" async&gt;&lt;/script&gt;<br>
				&lt;script&gt;<br>
				&nbsp;&nbsp;$('body').css('background', 'yellow');<br>
				&nbsp;&nbsp;var h1 = document.querySelector('h1');<br>
				&nbsp;&nbsp;h1.innerHTML = h1.innerHTML + '!!!';<br>
				&lt;/script&gt;<br>
				...
			</code>
			<p>Але тут є підводний камінь: бібліотека почне завантажуватися в фоні і паралельно з нею виконається наступна строка коду. При цьому знак долара ще не буде асоційований з jQuery-функцією.</p>
			<p>В такому випадку jQuery-код потрібно огорнути в подію load вікна:</p>
			<code>
				...<br>
				&lt;script src="js/jquery.min.js" async&gt;&lt;/script&gt;<br>
				&lt;script&gt;<br>
				&nbsp;&nbsp;window.addEventListener('load', function(){<br>
				&nbsp;&nbsp;&nbsp;&nbsp;$('body').css('background', 'yellow');<br>
				&nbsp;&nbsp;});<br>
				&nbsp;&nbsp;var h1 = document.querySelector('h1');<br>
				&nbsp;&nbsp;h1.innerHTML = h1.innerHTML + '!!!';<br>
				&lt;/script&gt;<br>
				...
			</code>
			<p>При цьому дві останні строчки кода виконаються одразу і паралельно із завантаженням аналітики, бібліотеки, а строчка, що фарбує фон сторінки в жовтий - лише після завантаження всього документа.</p>
			<h3>defer</h3>
			<p>Властивість тега <strong>defer</strong> також вказує на потребу в асинхронності завантаження скриптів, але не у їх виконанні (відкладене виконання).</p>
			<p>По-перше, хоч скрипти і будуть завантажуватися паралельно, проте, виконаються лише в кінці завантаження всієї сторінки.</p>
			<p>По-друге, буде дотримана послідовність виконання скриптів, що мають властивість defer.</p>
			<p>Розглянемо на прикладі:</p>
			<code>
				&lt;script defer src="s1.js"&gt;&lt;/script&gt;<br>
				&lt;script async src="big.js"&gt;&lt;/script&gt;<br>
				&lt;script defer src="s2.js"&gt;&lt;/script&gt;<br>
				&lt;script async src="small.js"&gt;&lt;/script&gt;<br>
				&lt;script defer src="s3.js"&gt;&lt;/script&gt;
			</code>
			<p>Скрипт big.js - великий плагін на пару мегабайт.</p>
			<p>Скрипт small.js - маленький файлик на декілька строк.</p>
			<p>
				Порядок виконання:
				- всі 5 файлів починають завантажуватися одночасно в паралельних потоках*, не заважаючи завантаженню сторінки;<br>
				- файл small.js швиденько завантажиться і почне виконувати свій скрипт;<br>
				- якщо файл big.js завантажиться раніше, ніж завантажиться вся сторінка - він почне виконувати свій скрипт;<br>
				- пронумеровані скрипти завантажаться, дочекаються завантаження всієї сторінки і почнуть виконуватися в заданому порядку (порядок виконання визначає не цифра в назві, а порядок слідування в html-коді).
			</p>
			<p>*) Насправді, сервер, як правило, обмежує кількість потоків, в чому можна переконатися дивлячись на сторінку з купою дрібних картинок-превюх, зазвичай вони завантажуються по 4 штуки паралельно, а не всі декілька десятків одночасно.</p>
			<p><strong class="danger">Увага!</strong> Властивість async не підтримується браузерами IE9-, в разі потреби продумайте логіку завантаження для застарілих браузерів.</p>
			<p>Асинхронно можна завантажувати лише скрипти, для асинхронного завантаження стилів просто виконайте скрипт, який динамічно створить тег &lt;link&gt; з відповідним атрибутом href у блоці &lt;head&gt;.</p>
			<p>Якщо вказати одночасно обидві властивості (порядок слідування не важливий):</p>
			<code>
				&lt;script async defer src="script1.js"&gt;&lt;/script&gt;<br>
				&lt;script defer src="script2.js" async&gt;&lt;/script&gt;
			</code>
			<p>то сучасні браузери проігнорують властивість defer і вважатимуть скрипт повністю асинхронним, а IE9- не знатиме що таке async і використає властивість defer.</p>
		</section>

		<section>
			<h2>Асинхронне виконання функцій.</h2>
			<p>Ми вже не раз стикалися з асинхронністю функцій. Наприклад, в останніх темах знайомилися з технологією ajax: запит на сервер йде синхронно, а відповідь від сервера є асинхронною, тобто, виконується паралельно, в той момент, коли сервер пришле відповідь.</p>
			<p>Всі реакції на події є також асинхронними і виконуються паралельно.</p>
			<p>setTimeout і setInterval запускають свої каллбек-функції також запускають в паралельних потоках.</p>
			<p>З асинхронним виконанням функцій потрібно бути обережним:</p>
			<code>
				var i = 10;<br>
				setInterval(function(){ console.log(i++); }, 500);<br>
				setInterval(function(){ console.log(i--); }, 500);
			</code>
			<p>Також у нас виникали проблеми зі слайдером через одночасне виконання функцій: автоматичне гортання і реакція на керування клавіш.</p>
			<p>Відловлювати помилки у паралельних потоках, що використовують спільний простір імен, глобальні змінні - велика морока, можна заблукати у трьох строчках коду:</p>
			<code>
				for (var i = 0; i < 10; i++){<br>
				&nbsp;&nbsp;setTimeout(function(){ console.log(i); }, i * 1000);<br>
				}
			</code>
			<p>А якщо потрібно відлагодити тисячі строк коду з десятками паралельних процесів - це може стати нездійсненою задачею, простіше все переписати з нуля і правильно.</p>
			<p>Розпаралелюванням обчислень, процесів займаються об'ємні та наукоємкі галузі інформатики, математики, криптографії.</p>
		</section>

		<section>
			<h2>Проміси</h2>
			<p>В редакцію ES-2015 добавлено об'єкти-обіцянки (promise), за допомогою яких зручно виконувати асинхронні дії.</p>
			<p>Проміс - це об'єкт, що містить стан виконання і зберігає функцію (яку отримав у якості аргумента під час створення).</p>
			<p>Проміс виконує свою функцію в той момент, коли викликаються його методи .then(funOk, funErr) або .catch(funErr). Після виконання асинхронного коду запуститься одна з переданих кал-бек функцій funOk чи funErr.</p>
			<p>Кожна з цих функцій може містити аргумент. В функцію funOk можна передати деякий результат виконання асинхронного коду (наприклад, отриману з сервера інформацію, розміри картинки, що загрузилася). В funErr можна передати помилку виконання (код помилки, строку, об'єкт - все, що самі придумаєте і що може знадобитися для відлагодження помилок).</p>
			<p>Поки що детальніше розгляньте проміси за <a href="https://learn.javascript.ru/promise" target="_blank">статтею на learn.javascript.ru</a>.</p>
		</section>

		<section>
			<h2>Fetch</h2>
			<p>Функція fetch заснована на промісах, заміняє XMLHttpRequest.</p>
			<p>Браузери IE не підтримують fetch, використайте <a href="https://github.com/github/fetch" target="_blank">поліфіл</a>, який буде емулювати цей метод в старих браузерах.</p>
			<p>Функція повертає проміс:</p>
			<code>
				// запит json-файла з сервера:<br>
				let promise = fetch('json/data.json');
			</code>
			<p>Другим аргументом в функцію можна передати необхідні налаштування:</p>
			<code>
				let url = 'hello.txt';<br>
				let options = {<br>
				&nbsp;&nbsp;method: 'POST',<br>
				&nbsp;&nbsp;body: 'login=user&amp;pwd=12345'<br>
				}<br>
				fetch(url, options).then(funOk, funErr);
			</code>
			<p>
				Опції:<br>
				<em>method</em> - метод передачі даних, GET чи POST;<br>
				<em>headers</em> - добавити заголовки запиту;<br>
				<em>body</em> - тіло запиту, дані, що будуть передані на сервер;<br>
				<em>mode</em> - режим кросдоменності;<br>
				<em>credentials</em> - передача додаткових даних про авторизацію, кукі;<br>
				<em>cache</em> - метод кешування запитів;<br>
				<em>redirect</em> - обробка редіректа.
			</p>
			<p>На проміси калбеки навішуються за допомогою метода .then():</p>
			<code>
				promise.then(funOk, funErr);<br>
				function funOk(){ console.log('All ok'); }<br>
				function funErr(){ console.log('Error!'); }
			</code>
			<p>З функцією fetch в калбеки передаються змінні, куди буде записано дані - результат запита:</p>
			<code>
				fetch(url, options).then(function(response){<br>
				&nbsp;&nbsp;console.log('all ok');<br>
				&nbsp;&nbsp;h1.innerHTML = response.text();<br>
				}, function(response){<br>
				&nbsp;&nbsp;console.log('error: ' + response.status);<br>
				});
			</code>
			<p>
				Результат відповіді сервера можна отримати в наступних форматах:<br>
				response.arrayBuffer();<br>
				response.blob();<br>
				response.formData();<br>
				response.json();<br>
				response.text();
			</p>
			<h3>Завдання.</h3>
			<ol>
				<li>Отримайте за допомогою функції fetch дані з текстового файлу і вставте їх в &lt;h1&gt;.</li>
				<li>
					Отримайте дані з файлу JSON та вбудуйте їх у веб-сторінку:
					<code>
						{<br>
						&nbsp;&nbsp;"name": "Молоток",<br>
						&nbsp;&nbsp;"descr": "Слюсарний молоток з дерев'яною ручкою",<br>
						&nbsp;&nbsp;"count": 21,<br>
						&nbsp;&nbsp;"price": 270<br>
						}<br><br>
						&lt;p class="name"&gt;Назва товару: &lt;span&gt;&lt;/span&gt;&lt;/p&gt;<br>
						&lt;p class="descr"&gt;Опис: &lt;span&gt;&lt;/span&gt;&lt;/p&gt;<br>
						&lt;p class="count"&gt;Кількість на складі: &lt;span&gt;&lt;/span&gt; шт.&lt;/p&gt;<br>
						&lt;p class="price"&gt;Ціна: &lt;span&gt;&lt;/span&gt; грн.&lt;/p&gt;
					</code>
				</li>
				<li>
					Отримайте файл files.json:
					<code>
						["a.txt", "b", "c.json"]
					</code>
					Створіть три цих файли і в кожен запишіть масив з декількох довільних чисел.<br>
					Створіть ланцюжк викликів: спочатку отримайте files.json, тоді - кожен з вказаних у ньому файлів та порахуйте суму усіх чисел у всіх файлах.
				</li>
				<li>Зверніться до неіснуючого файла та обробіть помилку.</li>
			</ol>
		</section>

		<!--<section>
			<h2>Технічне завдання на соціальну мережу.</h2>
			<ol>
				<li>На сторінку виводиться декілька свіжих постів.</li>
				<li>
					Кожен пост складається з таких елементів:<br>
					- автор;<br>
					- дата публікації (визначається автоматично);<br>
					- зображення (посилання на ресурс в інтернеті);<br>
					- коментар;<br>
					- кількість лайків.
				</li>
				<li>На лайк можна клацнути, збільшивши чи зменшивши їх загальну кількість.</li>
				<li>Внизу сторінки кнопка "Завантажити ще", при натисканні на кнопку дозавантажувати старіші пости.</li>
				<li>Зручно буде - доскроливши до низу одразу дозавантажувати нові пости.</li>
				<li>Кнопка "Створити пост", при натисненні на яку відкривається форма добавляння нового поста.</li>
			</ol>
			<p>Додаткові задачі для самостійного опрацювання і власного портфоліо:</p>
			<ol>
				<li>Періодичне автоматичне оновлення постів.</li>
				<li>Створити модуль авторизації, вхід на сайт під логіном-паролем (пароль має шифруватися в md5).</li>
				<li>Read-only режим для анонімних користувачів, для зареєстрованих - аватарки.</li>
				<li>Активація логіна через e-mail, відновлення забутого пароля.</li>
				<li>Можливість завантаження своїх зображень.</li>
				<li>Можливість створювати пости з відео (з ютуба) та декількома фотографіями (альбом).</li>
				<li>Робота з мітками (хеш-тегами).</li>
				<li>Приватні повідомлення.</li>
				<li>Можливість додавати коментарі до постів.</li>
				<li>Модерація коментарів автором, редагування постів.</li>
				<li>Модерація всієї мережі адміном, блокування користувачів.</li>
				<li>Збереження токенів (щоб користувачеві не приходилося весь час вводити логін-пароль).</li>
			</ol>
			<p>Також бажано використовувати препроцесори, зборщики, власні бібліотеки.</p>
			<p>
				Реалізувавши ці задачі ви створите повноцінну соціальну мережу, яка стане окрасою вашого портфоліо, показуючи, що ви вмієте працювати:<br>
				- з базою даних;<br>
				- з бекенд-скриптами;<br>
				- з авторизацією, токенами;<br>
				- з розподіленням ролей (анонім, користувач, автор, адмін);<br>
				- з e-mail;<br>
				- можете побудувати модель, логіку, взаємодію складного проекту.
			</p>
			<p>Кому цікаво реалізувати цей проект - з радістю допоможу підказками та консультаціями на рахунок технологій.</p>
		</section>


		<section>
			<h2>Бекенд ajax.</h2>
			<p>На минулому занятті ми познайомилися з отриманням ресурсів (файлів) з сервера.</p>
			<p>Використовуючи ajax ми можемо відправити на сервер деякі дані. Сервер їх отримає, обробить, виконає певні дії та поверне результат.</p>
			<p>Вся ця процедура схожа на функцію з аргументами (умовний приклад):</p>
			<code>
				// frontend, виконується на ваших ноутбуках, компах, телефонах:<br>
				var n = howManyLikesOfPost(7211);<br>
				$('#post_7211 .likes').text(n);<br><br>
				// backend, виконується на сервері в дата-центрі:<br>
				function howManyLikesOfPost(post_id){<br>
				&nbsp;&nbsp;database.open();<br>
				&nbsp;&nbsp;var n = database.table('posts').field('likes').record(post_id);<br>
				&nbsp;&nbsp;database.close();<br>
				&nbsp;&nbsp;return n;<br>
				}
			</code>
		</section>-->

		<section class="homework">
			<h2>Домашнє завдання.</h2>
			<ol>
				<li>
					Створіть нескінченну анімацію - червоний квадрат, що обертається.<br>
					Створіть масив з 1 млн. випадкових чисел від 1 до 1 млн. та скопіюйте його щоб отримати 2 екземпляра.<br>
					Під час створення масива анімація не відбувається. Запустіть функцію створення масива асинхронно - це не заважатиме працювати анімації.<br>
					Запустіть асинхронно два потока обчислень:<br>
					- перший поток повинен сортувати елементи за зростанням;<br>
					- другий поток повинен сортувати елементи за спаданням.<br>
					Відстежуйте час завершення сортування.
				</li>
				<li>Домашнє завдання по ajax виконайте за допомогою функції fetch.</li>
			</ol>
		</section>

	</div>
</div>

<script src="jquery-3.1.1.min.js"></script>
<script src="fe.js"></script>

</body>
</html>