<!DOCTYPE html>
<html>
<head>
	<title>Frontend. ECMAScript 6+</title>
	<meta charset="utf-8">
	<meta name="keywords" content="">
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="format-detection" content="telephone=no">
	<link type="text/css" rel="stylesheet" href="style.css">
</head>
<body>
<div id="mainwrapper">
	<div class="resize">

		<h1>ECMAScript 6+</h1>

		<section>
			<h2>Коротка історія JavaScript / ECMAScript</h2>
			<p>JavaScript - товарний знак, що належить компанії Oracle Corporation в США.</p>
			<p>ECMAScript належить організації ECMA (European Computer Manufacturers Association) - міжнародній організації, що займається регулюванням та стандартизацією у сферах IT та комунікації.</p>
			<p>Початкова розробка була здійснена в компанії Netscape, за прототип було взято скриптову мову Cmm (C--, ScriptEase), яка так і не здобула популярності. Змінивши декілька назв (Mocha, LiveScript/LiveWire) в 1995 році мова отримала назву JavaScript (під ліцензією Sun Microsystems, яку в 2010 році викупила Oracle).</p>
			<p>Microsoft в 1996 році випустив аналогічну скриптову мову JScript, вбудував його в IE3.</p>
			<p>Організація ECMA стандартизувала мови JavaScript, JScript і ScriptEase, прийнявши ECMAScript. Ці три скриптові мови є взаємосумісними, проте були ньюанси, варіанти реалізації BOM і DOM (дивись далі), що призводили до проблем крос-браузерності.</p>
			<p>Між першою та другою версіями було багато мінорних версій: 1.1, 1.2 ... 1.8</p>
			<p>ECMAScript 2 вийшов в червні 1998 року.</p>
			<p>ECMAScript 3 вийшов у грудні 1999 року.</p>
			<p>Робота над четвертою версією заглохла на пів-дорозі, вона так і не вийшла через сварки в консорціумі розробників, патенти, конкуренцію та лобіювання власних інтересів. Проте, технології, декларовані в цій версії, були реалізовані у різних браузерах (неофіційно).</p>
			<p>ECMAScript 5 вийшов у грудні 2009 року (переназвана версія 3.1, яку розробили на заміну 4-ї версії, відкинувши всі серйозні нововведення і зосередившись на оптимізації).</p>
			<p>Разом з впровадженням HTML5 та CSS3, виникненням нових концепцій веб-застосунків, прискоренням розробки браузерів (від 0,2-1 версії на рік до майже щомісячного реліза) ECMAScript також прискорився, впровадив багато нових можливостей, взяв курс на зближення з іншими мовами програмування.</p>
			<p>ECMAScript 6 / 2015 &mdash; березень 2015 року.</p>
			<p>Браузери не встигали завершити свій життєвий цикл, багато користувачів з різних причин сиділи на старих браузерах, що не підтримували нові можливості. Тому набули популярність транспайлери (конвертори нового JS в старий), наприклад, Babel, Traceur.</p>
			<p>ECMAScript 7 / 2016.</p>
			<p>ECMAScript 8 / 2017.</p>
			<p>ECMAScript 9 / 2018.</p>
			<p>Таким чином, JavaScript створюють та супроводжують декілька компаній: ECMA, Oracle, Microsoft, Mozilla. На деяких етапах історії також долучалися Adobe, Opera, Yahoo та інші компанії.</p>
		</section>

		


		<!--
			<p><a href="https://codeguida.com/post/1428" target="_blank">Codeguida.com: Що нового в ES2018</a>.</p>
		-->

		<section>
			<h2>Загальний огляд JavaScript</h2>
			<p>
				JavaScript складається з трьох компонентів:<br>
				- ядро (ECMAScript);<br>
				- об'єктна модель браузера (BOM);<br>
				- об'єктна модель документа (DOM).
			</p>
			<p>Таким чином, якщо JS використовується у вбудованій техніці, робототехніці, як мова сценаріїв (макросів) у програмах, іграх, то використовується лише ядро і додаткові інтерфейси для роботи з портами вводу/виводу, файловою системою і т.д., без BOM і DOM. Ядро і віртуальна машина доволі компактні і дозволяють вшити їх в ROM, CMOS-чіпи невеликого об'єму та розміру.</p>
			<p>BOM та DOM не стандартизуються організацією ECMA, специфікації розробляють спільноти WHATWG і W3C, а доки немає специфікацій - кожна з компаній-розробників ліпить свої варіанти реалізацій, що якраз і веде до проблем кросбраузерності.</p>
		</section>

		<section>
			<h2>Нові можливості ECMAScript 6 / 2015</h2>
			<code>
				<em>Похилим шрифтом в коді показані класичні реалізації</em>
			</code>
			<p>Оголошення констант <strong>const</strong> та локальних змінних <strong>let</strong></p>
			<p>Специфікація радить відмовитися від використання var.</p>
			<code>
				const COLUMNS_COUNT = 12;<br>
				for (let n = 1; n &lt;= COLUMNS_COUNT; n++) {<br>
				&nbsp;&nbsp;setTimeout(showMessage, n * 1000);<br>
				}<br>
				if (test) {<br>
				&nbsp;&nbsp;let str = 'hello';<br>
				&nbsp;&nbsp;...<br>
				}
			</code>
			<p>Змінні n та str будуть існувати лише в межах фігурних дужок</p>
			<p>Змінна n буде доступна в асинхронній функції showMessage зі значеннями 1, 2, 3...</p>
			<p>Оголошені змінні через let будуть доступні лише нижче по коду, в той час як змінні, оголошені через var будуть мати значення undefined вище по коду.</p>
			
			<p><strong>Відмова від IIFE</strong> (immediately invoked function expression) - як наслідок з області видимості let, const:</p>
			<code>
				<em>(function (){<br>
				&nbsp;&nbsp;var x = 42;<br>
				})();</em><br><br>
				{<br>
				&nbsp;&nbsp;let x = 42;<br>
				}
			</code>
			
			<p><strong>Дефолтні значення аргументів функції</strong></p>
			<code>
				function fun(a, b = 6, c = false) { ... }<br><br>
				<em>function fun(a, b, c) {<br>
				&nbsp;&nbsp;if (b === undefined) b = 6;<br>
				&nbsp;&nbsp;if (c === undefined) c = false;<br>
				}</em>
			</code>
			<p><strong>Іменовані аргументи функцій</strong></p>
			<code>
				function fun1({ x = 10, y }) { ... }<br>
				function fun2(s, b, { x, y }) { ... }<br>
				fun1({ y: 30 });<br>
				fun1({ x: 5, y: 42 });<br>
				fun1({ y: 42, x: 5 });<br>
				fun2('Вася', false, { x: 30, y: 0 });
			</code>
			<p><strong>Деструктуризація об'єктів</strong> (іменовані аргументи функцій якраз і використовують деструктуризацію).</p>
			<code>
				let arr = [40, 20, 0];<br>
				let [x, y, z] = arr;<br>
				let [a, , c] = arr;<br>
				let { name: n, age: a } = { name: 'Вася', age: 22 };<br>
				n === 'Вася', a === 22.
			</code>
			<p>Скорочений варіант з іменами змінних, що співпадають з іменами властивостей об'єкта (використовується розпаковування об'єкта):</p>
			<code>
				let { name, age } = { name: 'Вася', age: 22 };<br>
				name === 'Вася', age === 22.
			</code>
			<p>Корисна річ, зменшує писанину, покращує читаємість коду:</p>
			<code>
				let name = 'Masha';<br>
				let age = 17;<br><br>
				<em>var obj = { name: name, age: age, x: 4 };</em><br>
				let obj = <strong>{ name, age, x: 4 }</strong>;<br><br>
				<em>var x = obj.x;</em></em><br>
				let <strong>{x} = obj</strong>;<br>
				console.log(x); &nbsp;&nbsp; <em>// 4</em>
			</code>
			
			<p>Порівняйте два старих способа і один новий:</p>
			<code>
				<em>function padding(){<br>
				&nbsp;&nbsp;var top = '10px', right = '20px', bottom = '30px', left = '20px';<br>
				&nbsp;&nbsp;return [ top, right, bottom, left ];<br>
				}<br>
				var pad = padding();<br>
				var left = pad[3], right = pad[1];<br><br>
				function padding(){<br>
				&nbsp;&nbsp;var top = '10px', right = '20px', bottom = '30px', left = '20px';<br>
				&nbsp;&nbsp;return { top: top, right: right, bottom: bottom, left: left };<br>
				}<br>
				var pad = padding();<br>
				var left = pad.left, right = pad.right;</em><br><br>
				function padding(){<br>
				&nbsp;&nbsp;let top = '10px', right = '20px', bottom = '30px', left = '20px';<br>
				&nbsp;&nbsp;return { top, right, bottom, left };<br>
				}<br>
				let { left, right } = padding();
			</code>
			
			<p>Дозволяє досить просто обмінятися значеннями:</p>
			<code>
				let a = 10, b = 25;<br><br>
				<em>var tmp = a;<br>
				a = b;<br>
				b = tmp;</em><br><br>
				[a, b] = [b, a];
			</code>
			
			<p><strong>Spreads</strong> - зручне розпаковування масивів:</p>
			<code>
				function fun(a, b, c, d) { alert(a + b + c + d); }<br>
				const arr = [3, 4, 5, 6];<br>
				fun(...arr);<br>
				const brr = [1, 2, ...arr, 7, 8];<br>
				alert('Max: ' + Math.max(...arr));<br><br>
				<em>arr1 = arr1.concat(arr2, arr3);</em><br>
				arr1 = [...arr1, ...arr2, ...arr3];
			</code>
			<p>А ще ці три крапки дозволяють скопіювати об'єкт:</p>
			<code>
				let obj1 = { name: 'Вася', age: 22 };<br>
				let obj2 = { ...obj1 };
			</code>
			
			<p><strong>Стрілочні функції</strong></p>
			<p>Стрілочні функції завжди анонімні, не мають arguments та super, не можуть бути конструктором, не мають власного this, а використовують this з контексту вище.</p>
			<code>
				() => { ... }<br>
				<em>function (){ ... }</em><br><br>
				
				() => window.innerWidth / 2;<br>
				<em>function (){ return window.innerWidth / 2; }</em><br><br>
				
				() => alert('hello');<br>
				<em>function (){ return alert('hello'); }</em><br><br>
				
				(a, b, c) => { ... }<br>
				<em>function (a, b, c){ ... }</em><br><br>
				
				(a, b, c) => a + b * c;<br>
				<em>function (a, b, c){ return a + b * c; }</em><br><br>
				
				a => { ... }<br>
				a => a * a;<br>
				let obj = { sqr: a => a * a; }<br>
				obj.sqr(5); &nbsp;&nbsp; <em>// 25</em><br>
				<em>
					var obj = {<br>
					&nbsp;&nbsp;sqr: function(a){ return a * a; }<br>
					}
				</em><br><br>

				val => ({ str: val });<br>
				<em>function(val){ return { str: val }; }</em><br><br>

				(a, b, ...c) => { ... }<br>
				(a = 5, b, c = 'hey') => { ... }<br>
				let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;<br>
				f(); &nbsp;&nbsp; <em>// 6</em><br><br>

				function Person(){<br>
  			&nbsp;&nbsp;this.age = 0;<br>
  			&nbsp;&nbsp;setInterval(() => { this.age++; }, 1000);<br>
				}<br>
				let p = new Person();<br>
				<em>
					function Person(){<br>
	  			&nbsp;&nbsp;this.age = 0;<br>
	  			&nbsp;&nbsp;var that = this;<br>
	  			&nbsp;&nbsp;setInterval(function(){ that.age++; }, 1000);<br>
					}<br>
					var p = new Person();
				</em>
			</code>
			<p><strong>Класи</strong> (синтаксичний цукор поверх прототипів)</p>
			<p>JS рухається в бік повноцінного ООП.</p>
			<code>
				class User {<br>
				&nbsp;&nbsp;constructor(name, age){<br>
				&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;this.age = age;<br>
				&nbsp;&nbsp;}<br>
				&nbsp;&nbsp;hello(){<br>
				&nbsp;&nbsp;&nbsp;&nbsp;alert('Hello ' + this.name);<br>
				&nbsp;&nbsp;}<br>
				}<br>
				let user = new User('John', 25);<br>
				user.hello();<br><br>
				<em>
					function User(name, age){<br>
					&nbsp;&nbsp;this.name = name;<br>
					&nbsp;&nbsp;this.age = age;<br>
					}<br>
					User.prototype.hello = function(){<br>
					&nbsp;&nbsp;alert('Hello ' + this.name);<br>
					};<br>
					var user = new User('John', 25);<br>
					user.hello();
				</em><br><br>

				let User = class {<br>
  			&nbsp;&nbsp;sayHi() { alert('Привет!'); }<br>
				};<br>
				new User().sayHi();<br><br>
				
				<em>// наслідування:</em><br>
				class Customer extends User {<br>
				&nbsp;&nbsp;constructor(name, age, gender){<br>
				&nbsp;&nbsp;&nbsp;&nbsp;super.constructor(name);<br>
				&nbsp;&nbsp;&nbsp;&nbsp;this.gender = gender;<br>
				&nbsp;&nbsp;}<br>
				&nbsp;&nbsp;hello(){<br>
				&nbsp;&nbsp;&nbsp;&nbsp;super.hello();<br>
				&nbsp;&nbsp;&nbsp;&nbsp;console.log('gender: ' + this.gender);<br>
				&nbsp;&nbsp;}<br>
				}
			</code>
			<p>User, оголошений через class, неможна викликати без new (буде помилка).</p>
			<p>Оголошення class веде себе як let: клас буде доступний лише в поточному блоці і лише нижче по коду.</p>
			<p>Методи класа не злічені, вони не будуть доступні в конструкції for..in.</p>
			<p>Можна створювати статичні методи (ці методи не мають доступу до this і можуть викликатися без створення об'єкта). Приклад вам вже відомий, метод now статичний:</p>
			<code>
				let ms = Date.now();<br>
				let today = new Date();<br><br>
				class User {<br>
				&nbsp;&nbsp;constructor(name, role){<br>
				&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>
				&nbsp;&nbsp;&nbsp;&nbsp;this.role = role;<br>
				&nbsp;&nbsp;}<br>
				&nbsp;&nbsp;static anon(){<br>
				&nbsp;&nbsp;&nbsp;&nbsp;return new User('anon', 0);<br>
				&nbsp;&nbsp;}<br>
				}<br>
				let admin = new User('admin', 7);<br>
				let anon = User.anon();
			</code>
			<p><strong>Покращення об'єктних літералів</strong></p>
			<code>
				let offsetX = '70px';<br>
				let n = 42;<br>
				let obj = {<br>
				&nbsp;&nbsp;offsetX,<br>
				&nbsp;&nbsp;['item-' + n]: 'Sorok dva',<br>
				&nbsp;&nbsp;hello42(){ alert(this['item-42']); }<br>
				};<br><br>
				<em>var obj = {<br>
				&nbsp;&nbsp;offsetX: offsetX,<br>
				&nbsp;&nbsp;hello42: function(){ alert(this['item-42']); }<br>
				};<br>
				obj['item-' + n] = 'Sorok dva';</em>
			</code>
			<p><strong>Модулі</strong> - продвинутий варіант бібліотеки функцій.</p>
			<p>По-старому:</p>
			<code>
				var Math = {<br>
				&nbsp;&nbsp;PI: 3.14159,<br>
				&nbsp;&nbsp;sin: function (angle){ return ... ; },<br>
				&nbsp;&nbsp;cos: function (angle){ return ... ; },<br>
				&nbsp;&nbsp;__internalFunction: function (){ ... }<br>
				}
			</code>
			<p>По-новому:</p>
			<code>
				module Math {<br>
				&nbsp;&nbsp;export const PI = 3.14159,<br>
				&nbsp;&nbsp;export let step = 0,<br>
				&nbsp;&nbsp;export function sin(angle){ return ... ; }<br>
				&nbsp;&nbsp;export function cos(angle){ return ... ; }<br>
				&nbsp;&nbsp;internalFunction() { ... }<br>
				}
			</code>
			<p>При цьому службова функція internalFunction ззовні буде недоступна.</p>
			<p>Функції і змінні модуля можна імпортувати для більш зручного використання, область видомості імпорта обмежена конструкціями в фігурних дужках. Імпорт схожий на оператор with (не рекомендований до застосування):</p>
			<code>
				<em>let angleSin = Math.sin(angle * Math.PI / 180);</em><br><br>
				import Math.{sin, PI};<br>
				let angleSin = sin(angle * PI / 180);<br><br>
				import Math.*;<br>
				let angleSin = sin(angle * PI / 180);<br>
				let angleCos = cos(angle * PI / 180);<br>
				step++;<br>
				internalFunction(); &nbsp;&nbsp; <em>// тут буде помилка</em>
			</code>
			<p><strong>Цикл for-of</strong></p>
			<p>Зручний та очевидний перебір елементів масива:</p>
			<code>
				for (var i = 0; i &lt; arr.length; i++) { arr[i] - кожен елемент масива }<br>
				arr.forEach(function (e){ e - кожен елемент масива });<br>
				<strong>for (let e of arr)</strong> { e - кожен елемент масива }
			</code>
			<p><strong>Шаблонні літерали</strong></p>
			<p>Тепер для виокремлення строк можна використовувати не тільки одинарні та подвійні лапки, а й апостроф, що знаходиться під тільдою.</p>
			<p>Строка в цих апострофах може містити шаблони зі змінними, виразами, викликами функцій:</p>
			<code>
				const s = 'Masha';<br>
				alert('Hello ' + s + '!');<br>
				alert(<strong>`Hello ${s}!`</strong>);<br>
				alert(`Hello ${Math.sin(s.length) + 42}!`);
			</code>
			<p><strong>Багатострочні строки</strong></p>
			<code>
				<em>var s1 = 'lorem ipsum dolor ' +<br>
				&nbsp;&nbsp;'sit amet, consectetur ' +<br>
				&nbsp;&nbsp;'adipisicing elit.';<br>
				var s2 = 'lorem ipsum dolor ';<br>
				s2 += 'sit amet, consectetur ';<br>
				s2 += 'adipisicing elit.';</em><br><br>
				let s = `lorem ipsum dolor<br>
				sit amet, consectetur<br>
				adipisicing elit.`;
			</code>

			<p><strong>Генератори yield</strong></p>
			<p>Добавлені функції-генератори (TODO: дописати).</p>
			
			<p><strong>Проміси, Fetch</strong> (TODO: дописати).</p>
		</section>

		<section>
			<h2>Нові можливості ECMAScript 7 / 2016</h2>
		</section>

		<section>
			<h2>Нові можливості ECMAScript 8 / 2017</h2>
		</section>

		<section>
			<h2>Нові можливості ECMAScript 9 / 2018</h2>
		</section>
		
		<section>
			<h2>Нові можливості ECMAScript X / 2019</h2>
		</section>


		<!--<section>
			<h2>Анімація елементів</h2>
			<p>Потрібно плавно перерсунути блок вправо на 100px не використовуючи CSS-анімацію та JS-бібліотеки.</p>
			<p>Подумайте яким чином повинна відбуватися така анімація.</p>
			<p>Спробуйте зробити анімацію елемента, аналогічну jQuery.slideToggle().</p>
			<p>Зробіть схлопування блока, подібне до jQuery.slideUp(). Добавте розкривання блока, подібне до jQuery.slideUp()</p>
			<code>
				&lt;button&gt;move right 100px&lt;/button&gt;<br>
				&lt;button&gt;slideToggle&lt;/button&gt;<br>
				&lt;br&gt;&lt;br&gt;&lt;br&gt;<br>
				&lt;div&gt;lorem ipsum ...&lt;/div&gt;<br><br>
				div { padding: 12px 20px; width: 260px; border: 1px solid orange;}<br><br>
				moveRight(selector, duration){<br>
				&nbsp;&nbsp;???<br>
				}<br><br>
				slideToggle(selector, duration){<br>
				&nbsp;&nbsp;???<br>
				}
			</code>
		</section>
		
		<section class="homework">
			<h2>Домашнє завдання</h2>
			<ol>
				<li>Закінчіть практичне завдання.</li>
				<li>
					При кліку по body зробіть щоб блок рухався в точку кліка.
					<code>
						&lt;button&gt;round&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;<br>
						&lt;div&gt;hello&lt;/div&gt;<br><br>
						body { margin: 0; min-height: 100vh;}<br>
						div { position: absolute; left: 20px; top: 100px; font-size: 60px;}
					</code>
				</li>
				<li>Зробіть рух блока по колу при кліку на кнопку.</li>
				<li>При наведенні миші на блок плавно міняйте фоновий колір сторінки на рандомний безкінечно (по досягненні цільового кольору задайте новий рандомний колір і прагніть до нього).</li>
			</ol>
		</section>-->

	</div>
</div>

<script src="jquery-3.1.1.min.js"></script>
<script src="fe.js"></script>

</body>
</html>